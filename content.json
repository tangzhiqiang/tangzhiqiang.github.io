[{"title":"Spring Boot 结合 MongoDB 简单使用","date":"2019-07-29T03:39:48.000Z","path":"2019/07/29/Spring-Boot-结合-MongoDB-简单使用/","text":"1、什么是MongoDB ?MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB和关系数据库的对比 mongodb的增删改查Spring Boot对各种流行的数据源都进行了封装，当然也包括了mongodb,下面给大家介绍如何在spring boot中使用mongodb： 1、pom包配置 pom包里面添加spring-boot-starter-data-mongodb包引用 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、在application.properties中添加配置pom包里面添加spring-boot-starter-data-mongodb包引用 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、在application.properties中添加配置 1spring.data.mongodb.uri=mongodb://name:password@localhost:27017/admin 2、创建数据实体 12345678910111213141516@Data@ToStringpublic class User implements Serializable &#123; private static final long serialVersionUID = -3258839839160856613L; @Id private Long id; private String username; private Integer age; public User(Long id, String username, Integer age) &#123; this.id = id; this.username = username; this.age = age; &#125;&#125; 实现User的数据访问对象：UserRepository 12345678public interface UserRepository extends MongoRepository&lt;User, Long&gt; &#123; User findByUsername(String username); User findByUsernameAndAge(String username, Integer age); User findByAge(Integer age);&#125; 在单元测试中调用 1234567891011121314151617181920212223242526272829303132333435363738@RunWith(SpringRunner.class)@SpringBootTestpublic class MongodbApplicationTests &#123; @Autowired private UserRepository userRepository; @Test public void test1() throws Exception &#123;// User user = userRepository.findByAge(40);// System.out.println(user.toString()); User user1 = userRepository.findByUsernameAndAge(\"mama\", 40); System.out.println(user1.toString()); &#125; @Test public void test() throws Exception &#123; // 创建三个User，并验证User总数 userRepository.save(new User(1L, \"didi\", 30)); userRepository.save(new User(2L, \"mama\", 40)); userRepository.save(new User(3L, \"kaka\", 50)); Assert.assertEquals(3, userRepository.findAll().size()); // 删除一个User，再验证User总数 User u = userRepository.findById(1L).get(); System.out.println(u.toString()); userRepository.delete(u); Assert.assertEquals(2, userRepository.findAll().size()); // 删除一个User，再验证User总数 u = userRepository.findByUsername(\"mama\"); System.out.println(u.toString());// userRepository.delete(u); Assert.assertEquals(2, userRepository.findAll().size()); &#125;&#125; 使用 MongoTemplate 操作 创建 UserEntity 1234567@Datapublic class UserEntity implements Serializable &#123; private static final long serialVersionUID = -3258839839160856613L; private String userName; private String passWord;&#125; 创建实体dao的增删改查操作dao层实现了 UserEntity 对象的增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 @Componentpublic class UserEntityDao implements IUserEntityDao &#123; @Autowired private MongoTemplate mongoTemplate; public void save() &#123; UserEntity userEntity = new UserEntity(); userEntity.setUserName(\"mengma\"); userEntity.setPassWord(\"33333\"); mongoTemplate.save(userEntity); &#125; public UserEntity findByUserName(String username) &#123; // 使用 query 对象 声明查询 条件 Query query = new Query(Criteria.where(\"userName\").is(username)); UserEntity userEntity = mongoTemplate.findOne(query, UserEntity.class); return userEntity; &#125; /** * 通过 userName 更新 passWord * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/14 9:21 */ public void updateUser(String userName, String password) &#123; // 通过 query 对象 声明更新的条件 Query query = new Query(Criteria.where(\"userName\").is(userName)); // 通过 update 对象 声明更新字段 值 Update update = new Update().set(\"passWord\", password); UpdateResult updateResult = mongoTemplate.updateFirst(query, update, UserEntity.class); &#125; public void delByUsername(String username) &#123; Query query = new Query(Criteria.where(\"userName\").is(username)); mongoTemplate.remove(query, UserEntity.class); &#125; /** * 查询分页 * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/14 10:42 */ public void findPage(int size, int page, String username) &#123; // 通过 pageable 对象设置 分页条件 Pageable pageable = new PageRequest(page - 1, size); // 分页具体逻辑条件 Query query = new Query(Criteria.where(\"userName\").is(username)); List&lt;UserEntity&gt; userEntityList = mongoTemplate.find(query.with(pageable), UserEntity.class); System.out.println(userEntityList.toString()); &#125;&#125; 测试类 12345678910111213141516171819202122232425262728293031323334@RunWith(SpringRunner.class)@SpringBootTestpublic class UserEntityDaoTest &#123; @Autowired private UserEntityDao userEntityDao; @Test public void save() &#123; userEntityDao.save(); &#125; @Test public void findByUserName() &#123; UserEntity userEntity = userEntityDao.findByUserName(\"mengma\"); System.out.println(userEntity.toString()); &#125; @Test public void updateUser() &#123; userEntityDao.updateUser(\"mengma\", \"99999999\"); &#125; @Test public void delByUserName() &#123; userEntityDao.delByUsername(\"mengma\"); &#125; @Test public void findPage() &#123; userEntityDao.findPage(2, 1, \"mengma\"); &#125;&#125; 分页查询 123456789public void findPage(int size, int page, String username) &#123; // 通过 pageable 对象设置 分页条件 Pageable pageable = new PageRequest(page - 1, size); // 分页具体逻辑条件 Query query = new Query(Criteria.where(\"userName\").is(username)); List&lt;UserEntity&gt; userEntityList = mongoTemplate.find(query.with(pageable), UserEntity.class); System.out.println(userEntityList.toString()); &#125;","tags":[]},{"title":"spring data jpa 使用","date":"2019-07-29T03:39:32.000Z","path":"2019/07/29/spring-data-jpa-使用/","text":"spring data jpa介绍首先了解JPA是什么？JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。 注意:JPA是一套规范，不是一套产品，那么像Hibernate,TopLink,JDO他们是一套产品，如果说这些产品实现了这个JPA规范，那么我们就可以叫他们为JPA的实现产品。 spring data jpaSpring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！ 添加spring-data-jpa的支持12345&lt;!--引入JPA的依赖关系--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现 基本查询基本查询也分为两种，一种是spring data默认已经实现，一种是根据查询的方法来自动解析成SQL。 预先生成方法spring data jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等 实体类 12345678910@Entity @Table(name = \"t_user\") public class User implements Serializable &#123; @Idprivate Long id; private Integer balance; // 此处省略 getter 和 setter 方法。&#125; 1 继承JpaRepository 12public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 2 使用默认方法 1234567891011@Testpublic void testBaseQuery() throws Exception &#123; User user=new User(); userRepository.findAll(); userRepository.findOne(1l); userRepository.save(user); userRepository.delete(user); userRepository.count(); userRepository.exists(1l); // ...&#125; 就不解释了根据方法名就看出意思来 自定义简单查询 自定义的简单查询就是根据方法名来自动生成SQL，主要的语法是findXXBy,readAXXBy,queryXXBy,countXXBy, getXXBy后面跟属性名称： 也使用一些加一些关键字 And、 Or 1User findByUserNameOrEmail(String username, String email); 修改、删除、统计也是类似语法 123Long deleteById(Long id);Long countByUserName(String userName) 基本上SQL体系中的关键词都可以使用，例如：LIKE、 OrderBy。 123List&lt;User&gt; findByEmailLike(String email); List&lt;User&gt; findByUserNameOrderByEmailDesc(String email); 具体的关键字，使用方法和生产成SQL如下表所示 1 2 复杂查询在实际的开发中我们需要用到分页、删选、连表等查询的时候就需要特殊的方法或者自定义SQL 分页查询分页查询在实际使用中非常普遍了，spring data jpa 已经帮我们实现了分页的功能，在查询的方法中，需要传入参数 Pageable,当查询中有多个参数的时候 Pageable建议做为最后一个参数传入 123Page&lt;User&gt; findALL(Pageable pageable); Page&lt;User&gt; findByUserName(String userName,Pageable pageable); Pageable 是spring封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则 12345678@Testpublic void testPageQuery() throws Exception &#123; int page=1,size=10; Sort sort = new Sort(Direction.DESC, \"id\"); Pageable pageable = new PageRequest(page, size, sort); userRepository.findALL(pageable); userRepository.findByUserName(\"testName\", pageable);&#125; 限制查询 有时候我们只需要查询前N个元素，或者支取前一个实体。 123456789ser findFirstByOrderByLastnameAsc();User findTopByOrderByAgeDesc();Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable); 自定义SQL查询 其实Spring data 觉大部分的SQL都可以根据方法名定义的方式来实现，但是由于某些原因我们想使用自定义的SQL来查询，spring data也是完美支持的；在SQL的查询方法上面使用 @Query注解，如涉及到删除和修改在需要加上@Modifying.也可以根据需要添加 @Transactional对事物的支持，查询超时的设置等 123456789101112@Modifying@Query(\"update User u set u.userName = ?1 where c.id = ?2\")int modifyByIdAndUserId(String userName, Long id); @Transactional@Modifying@Query(\"delete from User where id = ?1\")void deleteByUserId(Long id); @Transactional(timeout = 10)@Query(\"select u from User u where u.emailAddress = ?1\") User findByEmailAddress(String emailAddress);","tags":[]},{"title":"spring-boot-cache 缓存提升系统响应速度","date":"2019-07-29T03:39:18.000Z","path":"2019/07/29/spring-boot-cache-缓存提升系统响应速度/","text":"1. 缓存简介缓存：缓存就是数据交换的缓冲区（称作Cache），当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。为什么使用缓存？究其原因就是缓存的读写速度远快与磁盘，从减轻I/O开销和加快运行速度方便都有很好的效果。那么我们缓存什么？哪些经常读取而又不经常修改的数据，那些数据量较大又很少修改的数据。缓存策略三要素：缓存命中率、缓存更新策略、最大缓存容量。 cache 可以说是后端提高响应速度、承载能力的标准套路了spring boot中提供spring boot starter cache 组件 配合spring boot starter redis 或者其他缓存组件 可以很简单的使用缓存。 2. spring cache 支持的缓存类型 Generic JCache (JSR-107) EhCache 2.x Hazelcast Infinispan Redis Guava Simple如果不满足上述的缓存方案 可以自实现 cacheManager。 注解介绍 @Cacheable 获取缓存 如果有缓存 直接返回。@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略。 value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个。如@Cacheable(value=”mycache”) 或者@Cacheable(value={”cache1”,”cache2”}key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合。如@Cacheable(value=”testcache”,key=”#userName”)condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存。如@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”) @CachePut执行并且更新缓存相关 不管如何 肯定会执行方法 然后返回 这样可以更新缓存的内容，@CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。 在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut也可以声明一个方法支持缓存功能。与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。 @CacheEvict删除缓存相关， @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。@CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。allEntries和beforeInvocation。allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。如：@CachEvict(value=”testcache”,allEntries=true) 。beforeInvocation：是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存。如：@CachEvict(value=”testcache”，beforeInvocation=true)allEntries指定为true时，则会清楚所有缓存。 @Caching @Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。使用如下 1234567@Caching(cacheable = &#123;@Cacheable(value = \"user\", key = \"#id\", condition = \"#id != '123'\"), @Cacheable(value = \"user\", key = \"#id\", condition = \"#id != '321'\")&#125; ) public User findById(String id) &#123; System.out.println(\"执行数据库查询方法\"); return userDao.findById(id); &#125; 实践 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 配置 12345678spring: redis: host: &lt;ip&gt; port: &lt;port&gt; password: &lt;password&gt; cache: # spring cache 缓存类型为redis 也可以是其他的实现 type: redis 使用cache 模拟带缓存的service 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.ming;import org.springframework.cache.annotation.CacheConfig;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.CachePut;import org.springframework.cache.annotation.Cacheable;import org.springframework.stereotype.Service;@Service//公共配置 可以在类上注释 注释本类的 缓存相关公共配置//@CacheConfig(cacheNames = TestCacheService.CACHE_KEY)public class TestCacheService &#123; public static final String CACHE_KEY = \"test-cache\"; /** * 获取信息 第二次访问会取缓存 * * @author ming * @date 2018-07-11 17:41:47 */ @Cacheable(cacheNames = CACHE_KEY ,key = \"#id\") public String testCache(String id) &#123; return getString(id); &#125; /** * 更新信息 更新缓存 * * @author ming * @date 2018-07-12 09:50:53 */ @CachePut(cacheNames = CACHE_KEY ,key = \"#id\") public String testCachePut(String id) &#123; return getString(id + \"update\"); &#125; /** * 清除缓存 * * @author ming * @date 2018-07-12 09:51:22 */ @CacheEvict(cacheNames = CACHE_KEY ,key = \"#id\") public void removeCache(String id) &#123; System.out.println(\"删除缓存 \"); &#125; /** * 获取string 模拟调用方法 * * @author ming * @date 2018-07-11 17:41:58 */ private String getString(String id) &#123; try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return id + \"load\"; &#125;&#125; 测试用例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ming;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = Start.class)public class TestCache &#123; @Autowired private TestCacheService testCacheService; @Test public void test() &#123; String id = \"ming\"; System.out.println(\"第一次访问没有缓存--------\"); long oneNow = System.currentTimeMillis(); System.out.println(testCacheService.testCache(id)); System.out.println(\"耗时:\" + (System.currentTimeMillis() - oneNow) + \"ms\"); System.out.println(\"第二次访问有缓存--------\"); long twoNow = System.currentTimeMillis(); System.out.println(testCacheService.testCache(id)); System.out.println(\"耗时:\" + (System.currentTimeMillis() - twoNow) + \"ms\"); System.out.println(\"更新缓存信息--------\"); long threeNow = System.currentTimeMillis(); System.out.println(testCacheService.testCachePut(id)); System.out.println(\"耗时:\" + (System.currentTimeMillis() - threeNow) + \"ms\"); System.out.println(\"获取更新后的缓存信息-------\"); long fourNow = System.currentTimeMillis(); System.out.println(testCacheService.testCache(id)); System.out.println(\"耗时:\" + (System.currentTimeMillis() - fourNow) + \"ms\"); System.out.println(\"移除缓存------并且调用testCache方法\"); testCacheService.removeCache(id); long fiveNow = System.currentTimeMillis(); System.out.println(testCacheService.testCache(id)); System.out.println(\"耗时:\" + (System.currentTimeMillis() - fiveNow) + \"ms\"); &#125;&#125; 注意事项 @Cacheable 、@CachePut、@CacheEvict 必须要有 cacheNames或 value注解必须放在public修饰的方法上。如果只是获取缓存使用@Cacheable即可 如果要更新数据库并且更新缓存一定要使用@CachePut 否则@Cacheable会出现脏读。 总结spring cache 为缓存提供了一套简单快捷的方案 可以很快速添加上缓存具体缓存的实现 也有更多的选择 也可以自己实现spring cache的缓存管理器 来实现自定义的缓存。","tags":[]},{"title":"使用spring security + JWT 权限认证","date":"2019-07-29T03:18:47.000Z","path":"2019/07/29/使用spring-security-JWT-权限认证/","text":"JWT 简介JWT是 json web token 缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证 token的正确性，只要正确即通过验证。 优点是在分布式系统中，很好地解决了单点登录问题，很容易解决了session共享的问题。 缺点是无法作废已颁布的令牌/不易应对数据过期。 JWT的结构 JWT包含了使用 . 分隔的三部分： Header 头部 Payload 负载 Signature 签名 其结构看起来是这样的 1xasdfasdfasdfxxxx.yydfdfdfdyyy.zzasdfasdfsadfasdfzzz Header在header中通常包含了两部分：token类型和采用的加密算法。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 接下来对这部分内容使用 Base64Url 编码组成了JWT结构的第一部分。 PayloadToken的第二部分是负载，它包含了claim， Claim是一些实体（通常指的用户）的状态和额外的元数据，有三种类型的claim： reserved , public 和 private . Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 iss（签发者） , exp（过期时间戳） , sub（面向的用户） , aud（接收方） , iat（签发时间） 。 Public claims：根据需要定义自己的字段，注意应该避免冲突 Private claims：这些是自定义的字段，可以用来在双方之间交换信息 负载使用的例子： 12345&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true&#125; 上述的负载需要经过 Base64Url 编码后作为JWT结构的第二部分。 Signature 创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建： 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 签名用于验证消息的发送者以及消息是没有经过篡改的。 完整的JWT JWT格式的输出是以 . 分隔的三段Base64编码，与SAML等基于XML的标准相比，JWT在HTTP和HTML环境中更容易传递。 下列的JWT展示了一个完整的JWT格式，它拼接了之前的Header， Payload以及秘钥签名： 如何使用JWT？在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。 当用户希望访问一个受保护的路由或者资源的时候，通常应该在 Authorization头部使用 Bearer 模式添加JWT，其内容看起来是下面这样： 1Authorization: Bearer &lt;token&gt; 因为用户的状态在服务端的内存中是不存储的，所以这是一种 无状态 的认证机制。服务端的保护路由将会检查请求头 Authorization 中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。 下面的序列图展示了该过程： 微服务中流程： 用户在提交登录信息后，服务器校验数据后将通过密钥的方式来生成一个字符串token返回给客户端，客户端在之后的请求会把token放在header里，在请求到达服务器后，服务器会检验和解密token，如果token被篡改或者失效将会拒绝请求，如果有效则服务器可以获得用户的相关信息并执行请求内容，最后将结果返回。在微服务架构下,通常有单独一个服务Auth去管理相关认证，为了安全不会直接让用户访问某个服务，会开放一个入口服务作为网关gateway，只允许外网网关，所有请求首先访问gateway，有gateway将请求路由到各个服务。 客户端请求网关后，网关会根据路径过滤请求，是登录获取token操作的路径则直接放行，请求直接到达auth服务进行登录操作，之后进行JWT私钥加密生成token返回给客户端；是其他请求将会进行token私钥解密校验，如果token被篡改或者失效则直接拒绝访问并返回错误信息，如果验证成功经过路由到达请求服务，请求服务响应并返回数据。 如何实现登录、刷新、注销等？登录比较简单，在验证身份信息后可以使用工具包例如jjwt根据用户信息生成token并设置有效时长，最后将token返回给客户端存储即可，客户端只需要每次访问时将token加在请求头里即可,然后在zuul增加一个filter,此filter来过滤请求，如果是登录获取token则放行，其他的话用公钥解密验证token是否有效。如果要实现刷新，则需要在生成token时生成一个refreshKey，在登录时和token一并返回给客户端，然后由客户端保存定时使用refreshKey和token来刷新获取新的有效时长的token,这个refreshKey可自定义生成，为了安全起见，服务器可能需要缓存refreshKey，可使用redis来进行存储，每次刷新token都将生成新的refreshKey和token，服务器需要将老refreshKey替换，客户端保存新的token和refreshKey来进行之后的访问和刷新。如果要实现注销，并使得旧的token即便在有效期内也不能通过验证，则需要修改登录、刷新、和优化zuul的filter。首先在登录时生成token和refreshKey后，需要将token也进行缓存，如果通过redis进行缓存可以直接放一个Set下，此Set存储所有未过期的token。其次，在刷新时在这个Set中删除旧的token并放入新的。最后对zuulFilter进行优化，在解密时先从redis里存放token的Set查找此token是否存在（redis的Set有提供方法），如果没有则直接拒绝，如果有再进行下一步解密验证有效时长，验证有效时长是为了防止刷新机制失效、没有刷新机制、网络异常强行退出等事件出现，在这种情况下旧的token没有被删除，导致了旧的token一直可以访问（如果只验证是否token是否在缓存中）。在注销时只需要删除redis中Set的token记录就好，最后写个定时器去定时删除redis中Set里面过时的token,原因也是刷新机制失效、没有刷新机制、网络异常强行退出等事件出现导致旧的token没有被删除。 为什么要使用JWT？相比XML格式，JSON更加简洁，编码之后更小。因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系。 spring security 简介Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。 HttpSecurity 常用方法及说明 实战 引入依赖 12345678910111213141516171819&lt;!--安全框架--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--JSON封装--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.36&lt;/version&gt;&lt;/dependency&gt;&lt;!--JWT--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; security 配置类 ,写一个继承于WebSecurityConfigurerAdapter的配置类,在重写带参httpsecurity,注入自定义的各种返回json的Handler 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Configurationpublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired AjaxAuthenticationEntryPoint authenticationEntryPoint; // 未登陆时返回 JSON 格式的数据给前端（否则为 html） @Autowired AjaxAuthenticationSuccessHandler authenticationSuccessHandler; // 登录成功返回的 JSON 格式数据给前端（否则为 html） @Autowired AjaxAuthenticationFailureHandler authenticationFailureHandler; // 登录失败返回的 JSON 格式数据给前端（否则为 html） @Autowired AjaxLogoutSuccessHandler logoutSuccessHandler; // 注销成功返回的 JSON 格式数据给前端（否则为 登录时的 html） @Autowired AjaxAccessDeniedHandler accessDeniedHandler; // 无权访问返回的 JSON 格式数据给前端（否则为 403 html 页面） @Autowired SelfUserDetailsService userDetailsService; // 自定义user @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; // JWT 拦截器 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 加入自定义的安全认证 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; // 去掉 CSRF（跨域） http.csrf().disable() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 使用 JWT，关闭session .and() // 未登陆时返回 JSON .httpBasic().authenticationEntryPoint(authenticationEntryPoint) .and() // 所有请求必须认证 .authorizeRequests() .anyRequest() // 认证的逻辑 .access(\"@rbacauthorityservice.hasPermission(request,authentication)\") // RBAC 动态 url 认证 .and() //开启登录 .formLogin() .loginPage(\"/\") .successHandler(authenticationSuccessHandler) // 登录成功 .failureHandler(authenticationFailureHandler) // 登录失败 .permitAll() .and() // 登出 .logout() .logoutSuccessHandler(logoutSuccessHandler) .permitAll(); // 记住我 http.rememberMe().rememberMeParameter(\"remember-me\") .userDetailsService(userDetailsService).tokenValiditySeconds(300); http.exceptionHandling().accessDeniedHandler(accessDeniedHandler); // 无权访问 JSON 格式的数据 //用重写的Filter替换掉原有的UsernamePasswordAuthenticationFilter实现使用json 数据也可以登陆 http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);// 设置执行其他工作前的 filter （最重要的验证 JWT） http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); // JWT Filter &#125; //注册自定义的UsernamePasswordAuthenticationFilter @Bean CustomAuthenticationFilter customAuthenticationFilter() throws Exception &#123; CustomAuthenticationFilter filter = new CustomAuthenticationFilter(); filter.setAuthenticationSuccessHandler(authenticationSuccessHandler); filter.setAuthenticationFailureHandler(authenticationFailureHandler); filter.setFilterProcessesUrl(\"/login/self\"); // 设置登陆接口名 //这句很关键，重用WebSecurityConfigurerAdapter配置的AuthenticationManager，不然要自己组装AuthenticationManager filter.setAuthenticationManager(authenticationManagerBean()); return filter; &#125;&#125; 编写高可用对象 123456789101112/** * @Auther: Tangzhiqiang * @Date: 2019/1/12 16:20 * @Description: 高可用对象那个 */@Datapublic class AjaxResponseBody implements Serializable &#123; private String status; private String msg; private Object result; private String jwtToken;&#125; 编写各返回 handler类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 没有权限处理类@Componentpublic class AjaxAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123; AjaxResponseBody responseBody = new AjaxResponseBody(); responseBody.setStatus(\"300\"); responseBody.setMsg(\"需要权限!\"); httpServletResponse.getWriter().write(JSON.toJSONString(responseBody)); &#125;&#125;// 未登陆时@Componentpublic class AjaxAuthenticationEntryPoint implements AuthenticationEntryPoint &#123; public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; AjaxResponseBody responseBody = new AjaxResponseBody(); responseBody.setStatus(\"000\"); responseBody.setMsg(\"未登录!\"); httpServletResponse.getWriter().write(JSON.toJSONString(responseBody)); &#125;&#125;// 登录失败@Componentpublic class AjaxAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; AjaxResponseBody responseBody = new AjaxResponseBody(); responseBody.setStatus(\"400\"); responseBody.setMsg(\"登陆失败\"); httpServletResponse.getWriter().write(JSON.toJSONString(responseBody)); &#125;&#125;// 登陆成功@Componentpublic class AjaxAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; AjaxResponseBody responseBody = new AjaxResponseBody(); responseBody.setStatus(\"00\"); responseBody.setMsg(\"登陆成功!\"); SelfUserDetails selfUserDetails = (SelfUserDetails) authentication.getPrincipal();// 创建 token ，并返回 ，设置过期时间为 300 秒 String jwtToken = JwtTokenUtil.generateToken(selfUserDetails.getUsername(), 300); responseBody.setJwtToken(jwtToken); response.getWriter().write(JSON.toJSONString(responseBody)); &#125;&#125;// 登出成功@Componentpublic class AjaxLogoutSuccessHandler implements LogoutSuccessHandler &#123; public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; AjaxResponseBody responseBody = new AjaxResponseBody(); responseBody.setStatus(\"100\"); responseBody.setMsg(\"登陆成功\"); httpServletResponse.getWriter().write(JSON.toJSONString(responseBody)); &#125;&#125; 最用要的 JWT 认证 filter 加密方式（对称加密，非对称加密）非对称加密：生成非对称加密密钥（使用jdk自带的keytool工具,注意配置好JAVA_HOME，cmd 输入以下命令就会生产密钥到cmd 所在目录）1keytool -genkey -alias jwt -keyalg RSA -keysize 1024 -validity 365 -keystore jwt.jks 使用keytool生成密钥，别名为 jwt，算法为RSA，有效期为 365天，文件名为jwt.jks,把文件保存在当前打开cmd的路径下,它提示输入密码,输入自定义密码，当前我设置为 mengma ，接下的输入可以全部忽略，回车即可，最后输入 y 确定，把生成的文件复制到resources目录下,写一个JwtTokenUtil 生成和解析方法。 JwtTokenUtil 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class JwtTokenUtil &#123; private static InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"jwt.jks\"); // 寻找证书文件 private static PrivateKey privateKey = null; private static PublicKey publicKey = null; static &#123; // 将证书文件里边的私钥公钥拿出来 try &#123; KeyStore keyStore = KeyStore.getInstance(\"JKS\"); // java key store 固定常量 keyStore.load(inputStream, \"mengma\".toCharArray()); privateKey = (PrivateKey) keyStore.getKey(\"jwt\", \"mengma\".toCharArray()); // jwt 为 命令生成整数文件时的别名 publicKey = keyStore.getCertificate(\"jwt\").getPublicKey(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * 使用私钥加密 token * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/13 20:43 */ public static String generateToken(String subject, int expirationSeconds) &#123; return Jwts.builder() .setClaims(null) .setSubject(subject) .setExpiration(new Date(System.currentTimeMillis() + expirationSeconds * 1000)) .signWith(SignatureAlgorithm.RS256, privateKey) .compact(); &#125; /** * * 不使用公钥私钥 加密token * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/13 20:41 */ public static String generateToken(String subject, int expirationSeconds, String salt) &#123; return Jwts.builder() .setClaims(null) .setSubject(subject) .setExpiration(new Date(System.currentTimeMillis() + expirationSeconds * 1000)) .signWith(SignatureAlgorithm.HS512, salt) // 不使用公钥私钥 .compact(); &#125; /** * * 通过 公钥解密token * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/13 20:40 */ public static String parseToken(String token) &#123; String subject = null; try &#123; Claims claims = Jwts.parser() .setSigningKey(publicKey) .parseClaimsJws(token).getBody(); subject = claims.getSubject(); &#125; catch (Exception e) &#123; &#125; return subject; &#125; /** * * 不嘛通过 公钥解密token * * @param: * @return: * @auther: Tangzhiqiang * @date: 2019/1/13 20:40 */ public static String parseToken(String token,String salt) &#123; String subject = null; try &#123; Claims claims = Jwts.parser() .setSigningKey(salt) // 不使用公钥私钥 .parseClaimsJws(token).getBody(); subject = claims.getSubject(); &#125; catch (Exception e) &#123; &#125; return subject; &#125;&#125; JwtAuthenticationTokenFilter 12345678910111213141516171819202122232425262728293031323334353637/** * @Auther: Tangzhiqiang * @Date: 2019/1/13 21:18 * @Description: OncePerRequestFilter 确保在一次请求只通过一次filter，而不需要重复执行。 */// TODO 还要实现 token 缓存@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired SelfUserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; String authHeader = request.getHeader(\"Authorization\"); if (authHeader != null &amp;&amp; authHeader.startsWith(\"Bearer \")) &#123; final String authToken = authHeader.substring(\"Bearer \".length()); String username = JwtTokenUtil.parseToken(authToken); if (username != null) &#123; UserDetails userDetails = userDetailsService.loadUserByUsername(username); if (userDetails != null) &#123; UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; &#125; &#125; chain.doFilter(request, response); &#125;&#125; 自定义 使用 json 格式登陆时filter （CustomAuthenticationFilter） 1234567891011121314151617181920212223242526272829303132333435/** * 自定义 json 登录 */public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123; @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; //attempt Authentication when Content-Type is json if (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123; UsernamePasswordAuthenticationToken authRequest = null; try &#123; String jsonString = GetRequestJsonUtils.getPostRequestJsonString(request); SelfUserDetails selfUserDetails = JsonUtils.jsonToPojo(jsonString,SelfUserDetails.class); authRequest = new UsernamePasswordAuthenticationToken( selfUserDetails.getUsername(), selfUserDetails.getPassword()); &#125; catch (Exception e) &#123; e.printStackTrace(); authRequest = new UsernamePasswordAuthenticationToken( \"\", \"\"); &#125; finally &#123; setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; //transmit it to UsernamePasswordAuthenticationFilter else &#123; return super.attemptAuthentication(request, response); &#125; &#125;&#125; 获取 post 请求 request 中的 json数据工具类 （GetRequestJsonUtils） 1234567891011121314151617181920212223public class GetRequestJsonUtils &#123; // 返回 json 字符串 public static String getPostRequestJsonString(HttpServletRequest request) &#123; BufferedReader br; StringBuilder sb = null; String jsonString = null; try &#123; br = new BufferedReader(new InputStreamReader( request.getInputStream())); String line = null; sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line); &#125; jsonString = URLDecoder.decode(sb.toString(), \"UTF-8\"); jsonString = jsonString.substring(jsonString.indexOf(\"&#123;\")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return jsonString; &#125;&#125; JsonUtils 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JsonUtils &#123; // 定义jackson对象 private static final ObjectMapper MAPPER = new ObjectMapper(); /** * 将对象转换成json字符串。 * &lt;p&gt;Title: pojoToJson&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param data * @return */ public static String objectToJson(Object data) &#123; try &#123; String string = MAPPER.writeValueAsString(data); return string; &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json结果集转化为对象 * * @param jsonData json数据 * @param beanType 对象中的object类型 * @return */ public static &lt;T&gt; T jsonToPojo(String jsonData, Class&lt;T&gt; beanType) &#123; try &#123; T t = MAPPER.readValue(jsonData, beanType); return t; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 将json数据转换成pojo对象list * &lt;p&gt;Title: jsonToList&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param jsonData * @param beanType * @return */ public static &lt;T&gt;List&lt;T&gt; jsonToList(String jsonData, Class&lt;T&gt; beanType) &#123; JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType); try &#123; List&lt;T&gt; list = MAPPER.readValue(jsonData, javaType); return list; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; 用户访问权限具体判断逻辑（RbacAuthorityService） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Component(\"rbacauthorityservice\")public class RbacAuthorityService &#123; public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123; Object userInfo = authentication.getPrincipal(); boolean hasPermission = false; if (userInfo instanceof UserDetails) &#123; String username = ((UserDetails) userInfo).getUsername(); Collection&lt;? extends GrantedAuthority&gt; authorities = ((UserDetails) userInfo).getAuthorities(); Iterator&lt;? extends GrantedAuthority&gt; iterator = authorities.iterator(); for (GrantedAuthority authority : authorities) &#123; if (authority.getAuthority().equals(\"ROLE_ADMIN\")) &#123; //admin 可以访问的资源 Set&lt;String&gt; urls = new HashSet(); urls.add(\"/sys/**\"); urls.add(\"/test/**\"); AntPathMatcher antPathMatcher = new AntPathMatcher(); for (String url : urls) &#123; if (antPathMatcher.match(url, request.getRequestURI())) &#123; hasPermission = true; break; &#125; &#125; &#125; &#125; //user可以访问的资源 Set&lt;String&gt; urls = new HashSet(); urls.add(\"/test/**\"); AntPathMatcher antPathMatcher = new AntPathMatcher(); for (String url : urls) &#123; if (antPathMatcher.match(url, request.getRequestURI())) &#123; hasPermission = true; break; &#125; &#125; return hasPermission; &#125; else &#123; return false; &#125; &#125;&#125; 未完持续。。。。。","tags":[]}]